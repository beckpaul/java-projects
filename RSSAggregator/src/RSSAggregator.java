import java.io.File;
import java.io.IOException;

import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;
import components.xmltree.XMLTree;
import components.xmltree.XMLTree1;

/**
 * Program to convert an XML RSS (version 2.0) feed from a given URL into the
 * corresponding HTML and an index.
 *
 * @author Beckham Paul
 *
 */
public final class RSSAggregator {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private RSSAggregator() {
    }

    /**
     * Validate top level element as valid RSS tag.
     *
     * @param xml
     *            XML tree to validate as RSS
     *
     * @return if xml element is a valid RSS tag
     */

    private static boolean validateRSSTag(XMLTree xml) {
        final String desiredRssVersion = "2.0";
        final String rssString = "rss";
        boolean isValid = false;
        if (xml.isTag()) {
            if ((xml.attributeValue("version").equals(desiredRssVersion))
                    && (xml.label().equals(rssString))) {
                isValid = true;
            }
        }
        return isValid;
    }

    /**
     * Process RSS URL, validate and prompt for new input if invalid.
     *
     * @param url
     *            the input stream
     * @param out
     *            the output stream
     * @ensures attribute value of top level element matches desiredRSSVersion
     *
     * @return Channel element of valid RSS feed
     */
    private static XMLTree getRSSChannel(String url, SimpleWriter out) {
        XMLTree xml = new XMLTree1(url);
        boolean validRSS = validateRSSTag(xml);

        if (validRSS) {
            return xml.child(0);
        } else {
            XMLTree emptyXml = new XMLTree1("");
            return emptyXml;

        }
    };

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>the channel tag title as the page title</title>
     * </head> <body>
     * <h1>the page title inside a link to the <channel> link</h1>
     * <p>
     * the channel description
     * </p>
     * <table border="1">
     * <tr>
     * <th>Date</th>
     * <th>Source</th>
     * <th>News</th>
     * </tr>
     *
     * @param channel
     *            the channel element XMLTree
     * @param out
     *            the output stream
     * @updates out.content
     * @requires [the root of channel is a <channel> tag] and out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputHeader(XMLTree channel, SimpleWriter out) {
        assert channel != null : "Violation of: channel is not null";
        assert out != null : "Violation of: out is not null";
        assert channel.isTag() && channel.label().equals("channel") : ""
                + "Violation of: the label root of channel is a <channel> tag";
        assert out.isOpen() : "Violation of: out.is_open";

        int channelTitleIndex = getChildElement(channel, "title"),
                channelLinkIndex = getChildElement(channel, "link"),
                channelDescriptionIndex = getChildElement(channel,
                        "description");

        //Print title
        out.println("<html> \n <head> \n  <title>");
        if (channel.numberOfChildren() == 0) {
            out.println("   Empty Title");
        } else {
            out.println("   " + channel.child(channelTitleIndex).child(0));
        }
        out.println("  </title>\n </head> \n <body>");

        out.println("  <h1><a href=\""
                + channel.child(channelLinkIndex).child(0) + "\">"
                + channel.child(channelTitleIndex).child(0) + "</a></h1>");

        out.print("  <p>");

        // Print description
        if (channel.child(channelDescriptionIndex).numberOfChildren() == 0) {
            out.print("No description");
        } else {
            out.print(channel.child(channelDescriptionIndex).child(0));
        }
        out.print("  </p>");

        // Print table headers and table tag
        out.println("\n  <table border=\"1\">\n   <tr> \n    <th>Date</th> \n"
                + "    <th>Source</th>\n    <th>News</th>\n" + "  </tr>");
    }

    /**
     * Outputs the "closing" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * </table>
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    private static void outputFooter(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        out.println("  </table>");
        out.print(" </body>\n</html>");
    }

    /**
     * Outputs the header for index file and begins the body
     *
     * <html> <head> <title>the feeds tag title as the page title</title>
     * </head> <body>
     * <h1>Top Stories</h1>
     *
     * @param feeds
     *            the feeds element XMLTree
     * @param out
     *            the output stream
     * @updates out.content
     * @requires [the root of channel is a <channel> tag] and out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void processFeedsHeader(XMLTree feeds, SimpleWriter out) {
        assert feeds != null : "Violation of: XMLFeeds is not null";
        assert feeds
                .isTag() : "Violation of: the label root of XMLFEEDS is a tag";
        String title = feeds.attributeValue("title");
        out.println("<html> \n <head> \n  <title>" + title + "</title>");
        out.println(" </head> \n <body> \n <h2>" + title + "</h2>");
    }

    /**
     * Finds the first occurrence of the given tag among the children of the
     * given {@code XMLTree} and return its index; returns -1 if not found.
     *
     * @param xml
     *            the {@code XMLTree} to search
     * @param tag
     *            the tag to look for
     * @return the index of the first child of type tag of the {@code XMLTree}
     *         or -1 if not found
     * @requires [the label of the root of xml is a tag]
     * @ensures <pre>
     * getChildElement =
     *  [the index of the first child of type tag of the {@code XMLTree} or
     *   -1 if not found]
     * </pre>
     */
    private static int getChildElement(XMLTree xml, String tag) {
        assert xml != null : "Violation of: xml is not null";
        assert tag != null : "Violation of: tag is not null";
        assert xml.isTag() : "Violation of: the label root of xml is a tag";

        for (int i = 0; i <= xml.numberOfChildren() - 1; i++) {
            if (xml.child(i).label().equals(tag)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Processes one news item and outputs one table row. The row contains three
     * elements: the publication date, the source, and the title (or
     * description) of the item.
     *
     * @param item
     *            the news item
     * @param out
     *            the output stream
     * @updates out.content
     * @requires [the label of the root of item is an <item> tag] and
     *           out.is_open
     * @ensures <pre>
     * out.content = #out.content *
     *   [an HTML table row with publication date, source, and title of news item]
     * </pre>
     */
    private static void processItem(XMLTree item, SimpleWriter out) {
        assert item != null : "Violation of: item is not null";
        assert out != null : "Violation of: out is not null";
        assert item.isTag() && item.label().equals("item") : ""
                + "Violation of: the label root of item is an <item> tag";
        assert out.isOpen() : "Violation of: out.is_open";

        int itemPubDateIndex = getChildElement(item, "pubDate"),
                itemTitleIndex = getChildElement(item, "title"),
                itemLinkIndex = getChildElement(item, "link"),
                itemSourceIndex = getChildElement(item, "source"),
                itemDescriptionIndex = getChildElement(item, "description");

        out.println("   <tr>");
        // Print publish date
        out.print("    <td>");
        if (itemPubDateIndex == -1) {
            out.print("No date available");
        } else {
            out.print(item.child(itemPubDateIndex).child(0));
        }
        out.println("</td>");
        // Print Source
        out.print("    <td>");
        if (itemSourceIndex == -1) {
            out.print("No source available");
        } else {
            out.print(item.child(itemSourceIndex).child(0));
        }
        out.println("</td>");
        // Print description and link
        out.print("    <td>");

        boolean hasTitle = (itemTitleIndex >= 0)
                && (item.child(itemTitleIndex).numberOfChildren() >= 1);

        boolean hasLink = (itemLinkIndex >= 0)
                && (item.child(itemLinkIndex).numberOfChildren() >= 1);
        boolean hasDescription = (itemDescriptionIndex >= 0)
                && (item.child(itemDescriptionIndex).numberOfChildren() >= 1);

        if (hasTitle || hasLink) {
            if (hasTitle) {
                out.print("<p>" + item.child(itemTitleIndex).child(0) + "</p>");
            } else if (hasLink) {
                if (hasDescription) {
                    out.print("<a href=\"" + item.child(itemLinkIndex).child(0)
                            + "\">" + item.child(itemDescriptionIndex).child(0)
                            + "</a>");
                } else {
                    out.print("<a href=\"" + item.child(itemLinkIndex).child(0)
                            + "\"> No Description found. </a>");
                }
            }
        } else {
            out.print("No link or title found");
        }

    }

    /**
     * Processes one XML RSS (version 2.0) feed from a given URL converting it
     * into the corresponding HTML output file.
     *
     * @param fileName
     *            the name for the file to be created
     */
    private static void createFile(String fileName) {
        File file = new File(fileName);
        try {
            file.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Processes one XML RSS (version 2.0) feed from a given URL converting it
     * into the corresponding HTML output file.
     *
     * @param url
     *            the URL of the RSS feed
     * @param file
     *            the name of the HTML output file
     * @param out
     *            the output stream to report progress or errors
     * @updates out.content
     * @requires out.is_open
     * @ensures <pre>
     * [reads RSS feed from url, saves HTML document with table of news items
     *   to file, appends to out.content any needed messages]
     * </pre>
     */
    private static void processFeed(String url, String file, SimpleWriter out) {
        // Create associated file
        createFile(file);
        //Get channel from the rss for the item
        XMLTree channel = getRSSChannel(url, out);
        // Populate files
        outputHeader(channel, out);
        for (int i = getChildElement(channel, "item"); i < channel
                .numberOfChildren(); i++) {
            processItem(channel.child(i), out);
        }
        outputFooter(out);
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments; unused here
     */
    public static void main(String[] args) {
        SimpleReader in = new SimpleReader1L();
        SimpleWriter out = new SimpleWriter1L();

        out.print("Please provide the name of an XML file to be read: ");
        String url = in.nextLine();
        XMLTree feeds = new XMLTree1(url);

        // Create index and index writer
        final String indexPath = "index.html";
        createFile(indexPath);
        SimpleWriter indexWriter = new SimpleWriter1L(indexPath);

        // Index header
        processFeedsHeader(feeds, indexWriter);

        // Index body
        indexWriter.println(" <ul>");
        for (int i = 0; i < feeds.numberOfChildren(); i++) {
            // Populate index link
            XMLTree feed = feeds.child(i);
            final String fileName = feed.attributeValue("file");
            indexWriter.print("  <li>\n    <a href=\"" + fileName + "\">");
            indexWriter.println(feed.attributeValue("name") + "</a>\n  </li>");

            // Process the feed
            SimpleWriter feedWriter = new SimpleWriter1L(fileName);
            processFeed(feed.attributeValue("url"), fileName, feedWriter);
            feedWriter.close();
        }

        //Index Footer
        indexWriter.print(" </ul>\n </body>\n</html>");
        indexWriter.close();

        out.println("Output to HTML complete.");

        in.close();
        out.close();
    }

}
